package sessions

import (
	"errors"
	"sync"
	"time"

	"yumi/pkg/random"
	"yumi/pkg/types"
)

var (
	// ErrorNoSeesion ...
	ErrorNoSeesion = errors.New("sessions: no session in result")
)

// Default flashes key.
const flashesKey = "_flash"

var _maxAge = time.Hour * 2
var mux sync.Mutex

// Session --------------------------------------------------------------------

// newSessionID ...
func newSessionID() string {
	// FIXME: 改进生成sessionid方法
	return random.GetString(32)
}

// NewSession is called by session stores to create a new session instance.
func NewSession(store Store, name, client string, limit int) (*Session, error) {
	mux.Lock()
	defer mux.Unlock()
	len, err := getSessionLen(store, name, client)
	if err != nil {
		return nil, err
	}
	if len >= limit && limit != -1 {
		err = deleteSession(store, name, client, limit)
		if err != nil {
			return nil, err
		}
	}

	return &Session{
		ID:     newSessionID(),
		Values: make(map[interface{}]interface{}),
		store:  store,

		client:     client,
		name:       name,
		expireTime: types.Timestamp(time.Now().Add(_maxAge).Unix()),
		maxAge:     _maxAge,
	}, nil
}

// GetSession ...
func GetSession(store Store, sessID string) (*Session, error) {
	return store.Get(sessID)
}

// getSessionLen ...
func getSessionLen(store Store, name, client string) (int, error) {
	return store.GetLen(name + client)
}

// deleteSession ...
func deleteSession(store Store, name, client string, number int) error {
	return nil
}

// Session stores the values and optional configuration for a session.
type Session struct {
	// The ID of the session, generated by stores. It should not be used for
	// user data.
	ID string
	// Values contains the user-data for the session.
	Values map[interface{}]interface{}

	expireTime types.Timestamp
	maxAge     time.Duration
	client     string
	name       string
	store      Store
}

// GetValues ...
func (s *Session) GetValues(key string) []interface{} {
	var flashes []interface{}
	if key == "" {
		key = flashesKey
	}

	if v, ok := s.Values[key]; ok {
		flashes = v.([]interface{})
	}
	return flashes
}

// Flashes returns a slice of flash messages from the session.
//
// A single variadic argument is accepted, and it is optional: it defines
// the flash key. If not defined "_flash" is used by default.
func (s *Session) Flashes(vars ...string) []interface{} {
	var flashes []interface{}
	key := flashesKey
	if len(vars) > 0 {
		key = vars[0]
	}
	if v, ok := s.Values[key]; ok {
		// Drop the flashes and return it.
		delete(s.Values, key)
		flashes = v.([]interface{})
	}
	return flashes
}

// AddFlash adds a flash message to the session.
//
// A single variadic argument is accepted, and it is optional: it defines
// the flash key. If not defined "_flash" is used by default.
func (s *Session) AddFlash(value interface{}, vars ...string) {
	key := flashesKey
	if len(vars) > 0 {
		key = vars[0]
	}
	var flashes []interface{}
	if v, ok := s.Values[key]; ok {
		flashes = v.([]interface{})
	}
	s.Values[key] = append(flashes, value)
}

// Name returns the name used to register the session.
func (s *Session) Name() string {
	return s.name
}

// Store returns the session store used to register the session.
func (s *Session) Store() Store {
	return s.store
}

// Save ...
func (s *Session) Save() error {
	s.expireTime = types.Timestamp(time.Now().Add(_maxAge).Unix())
	return s.store.Save(s)
}
